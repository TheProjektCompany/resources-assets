/*! shepherd.js 11.2.0 */
!function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).Shepherd = e();
}(this, function () {
  "use strict";

  var t = function (t) {
    return function (t) {
      return !!t && "object" == typeof t;
    }(t) && !function (t) {
      var n = Object.prototype.toString.call(t);
      return "[object RegExp]" === n || "[object Date]" === n || function (t) {
        return t.$$typeof === e;
      }(t);
    }(t);
  };
  var e = "function" == typeof Symbol && Symbol.for ? Symbol.for("react.element") : 60103;
  function n(t, e) {
    return !1 !== e.clone && e.isMergeableObject(t) ? l((n = t, Array.isArray(n) ? [] : {}), t, e) : t;
    var n;
  }
  function o(t, e, o) {
    return t.concat(e).map(function (t) {
      return n(t, o);
    });
  }
  function i(t) {
    return Object.keys(t).concat(function (t) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(t).filter(function (e) {
        return Object.propertyIsEnumerable.call(t, e);
      }) : [];
    }(t));
  }
  function s(t, e) {
    try {
      return e in t;
    } catch (t) {
      return !1;
    }
  }
  function r(t, e, o) {
    var r = {};
    return o.isMergeableObject(t) && i(t).forEach(function (e) {
      r[e] = n(t[e], o);
    }), i(e).forEach(function (i) {
      (function (t, e) {
        return s(t, e) && !(Object.hasOwnProperty.call(t, e) && Object.propertyIsEnumerable.call(t, e));
      })(t, i) || (s(t, i) && o.isMergeableObject(e[i]) ? r[i] = function (t, e) {
        if (!e.customMerge) return l;
        var n = e.customMerge(t);
        return "function" == typeof n ? n : l;
      }(i, o)(t[i], e[i], o) : r[i] = n(e[i], o));
    }), r;
  }
  function l(e, i, s) {
    (s = s || {}).arrayMerge = s.arrayMerge || o, s.isMergeableObject = s.isMergeableObject || t, s.cloneUnlessOtherwiseSpecified = n;
    var l = Array.isArray(i);
    return l === Array.isArray(e) ? l ? s.arrayMerge(e, i, s) : r(e, i, s) : n(i, s);
  }
  l.all = function (t, e) {
    if (!Array.isArray(t)) throw new Error("first argument should be an array");
    return t.reduce(function (t, n) {
      return l(t, n, e);
    }, {});
  };
  var c = l;
  function a(t) {
    return t instanceof HTMLElement;
  }
  function u(t) {
    return "function" == typeof t;
  }
  function f(t) {
    return "string" == typeof t;
  }
  function h(t) {
    return void 0 === t;
  }
  class d {
    on(t, e, n, o = !1) {
      return h(this.bindings) && (this.bindings = {}), h(this.bindings[t]) && (this.bindings[t] = []), this.bindings[t].push({
        handler: e,
        ctx: n,
        once: o
      }), this;
    }
    once(t, e, n) {
      return this.on(t, e, n, !0);
    }
    off(t, e) {
      return h(this.bindings) || h(this.bindings[t]) || (h(e) ? delete this.bindings[t] : this.bindings[t].forEach((n, o) => {
        n.handler === e && this.bindings[t].splice(o, 1);
      })), this;
    }
    trigger(t, ...e) {
      return !h(this.bindings) && this.bindings[t] && this.bindings[t].forEach((n, o) => {
        const {
            ctx: i,
            handler: s,
            once: r
          } = n,
          l = i || this;
        s.apply(l, e), r && this.bindings[t].splice(o, 1);
      }), this;
    }
  }
  function p(t) {
    const e = Object.getOwnPropertyNames(t.constructor.prototype);
    for (let n = 0; n < e.length; n++) {
      const o = e[n],
        i = t[o];
      "constructor" !== o && "function" == typeof i && (t[o] = i.bind(t));
    }
    return t;
  }
  function m(t) {
    const {
      event: e,
      selector: n
    } = t.options.advanceOn || {};
    if (!e) return void 0;
    {
      const o = function (t, e) {
        return n => {
          if (e.isOpen()) {
            const o = e.el && n.currentTarget === e.el;
            (!h(t) && n.currentTarget.matches(t) || o) && e.tour.next();
          }
        };
      }(n, t);
      let i;
      try {
        i = document.querySelector(n);
      } catch (t) {}
      if (!h(n) && !i) return void 0;
      i ? (i.addEventListener(e, o), t.on("destroy", () => i.removeEventListener(e, o))) : (document.body.addEventListener(e, o, !0), t.on("destroy", () => document.body.removeEventListener(e, o, !0)));
    }
  }
  function g(t) {
    return f(t) && "" !== t ? "-" !== t.charAt(t.length - 1) ? `${t}-` : t : "";
  }
  function y(t) {
    return null == t || !t.element || !t.on;
  }
  function b() {
    let t = Date.now();
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, e => {
      const n = (t + 16 * Math.random()) % 16 | 0;
      return t = Math.floor(t / 16), ("x" == e ? n : 3 & n | 8).toString(16);
    });
  }
  function x() {
    return x = Object.assign ? Object.assign.bind() : function (t) {
      for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e];
        for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
      }
      return t;
    }, x.apply(this, arguments);
  }
  function $(t, e) {
    if (null == t) return {};
    var n,
      o,
      i = {},
      s = Object.keys(t);
    for (o = 0; o < s.length; o++) n = s[o], e.indexOf(n) >= 0 || (i[n] = t[n]);
    return i;
  }
  const v = Math.min,
    w = Math.max,
    O = Math.round,
    E = Math.floor,
    T = t => ({
      x: t,
      y: t
    }),
    S = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    },
    _ = {
      start: "end",
      end: "start"
    };
  function A(t, e, n) {
    return w(t, v(e, n));
  }
  function I(t, e) {
    return "function" == typeof t ? t(e) : t;
  }
  function L(t) {
    return t.split("-")[0];
  }
  function P(t) {
    return t.split("-")[1];
  }
  function C(t) {
    return "x" === t ? "y" : "x";
  }
  function k(t) {
    return "y" === t ? "height" : "width";
  }
  function R(t) {
    return ["top", "bottom"].includes(L(t)) ? "y" : "x";
  }
  function M(t) {
    return C(R(t));
  }
  function j(t) {
    return t.replace(/start|end/g, t => _[t]);
  }
  function F(t) {
    return t.replace(/left|right|bottom|top/g, t => S[t]);
  }
  function D(t) {
    return "number" != typeof t ? function (t) {
      return x({
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }, t);
    }(t) : {
      top: t,
      right: t,
      bottom: t,
      left: t
    };
  }
  function H(t) {
    return x({}, t, {
      top: t.y,
      left: t.x,
      right: t.x + t.width,
      bottom: t.y + t.height
    });
  }
  const B = ["mainAxis", "crossAxis", "fallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "flipAlignment"],
    N = ["mainAxis", "crossAxis", "limiter"];
  function V(t, e, n) {
    let {
      reference: o,
      floating: i
    } = t;
    const s = R(e),
      r = M(e),
      l = k(r),
      c = L(e),
      a = "y" === s,
      u = o.x + o.width / 2 - i.width / 2,
      f = o.y + o.height / 2 - i.height / 2,
      h = o[l] / 2 - i[l] / 2;
    let d;
    switch (c) {
      case "top":
        d = {
          x: u,
          y: o.y - i.height
        };
        break;
      case "bottom":
        d = {
          x: u,
          y: o.y + o.height
        };
        break;
      case "right":
        d = {
          x: o.x + o.width,
          y: f
        };
        break;
      case "left":
        d = {
          x: o.x - i.width,
          y: f
        };
        break;
      default:
        d = {
          x: o.x,
          y: o.y
        };
    }
    switch (P(e)) {
      case "start":
        d[r] -= h * (n && a ? -1 : 1);
        break;
      case "end":
        d[r] += h * (n && a ? -1 : 1);
    }
    return d;
  }
  async function W(t, e) {
    var n;
    void 0 === e && (e = {});
    const {
        x: o,
        y: i,
        platform: s,
        rects: r,
        elements: l,
        strategy: c
      } = t,
      {
        boundary: a = "clippingAncestors",
        rootBoundary: u = "viewport",
        elementContext: f = "floating",
        altBoundary: h = !1,
        padding: d = 0
      } = I(e, t),
      p = D(d),
      m = l[h ? "floating" === f ? "reference" : "floating" : f],
      g = H(await s.getClippingRect({
        element: null == (n = await (null == s.isElement ? void 0 : s.isElement(m))) || n ? m : m.contextElement || (await (null == s.getDocumentElement ? void 0 : s.getDocumentElement(l.floating))),
        boundary: a,
        rootBoundary: u,
        strategy: c
      })),
      y = "floating" === f ? x({}, r.floating, {
        x: o,
        y: i
      }) : r.reference,
      b = await (null == s.getOffsetParent ? void 0 : s.getOffsetParent(l.floating)),
      $ = (await (null == s.isElement ? void 0 : s.isElement(b))) && (await (null == s.getScale ? void 0 : s.getScale(b))) || {
        x: 1,
        y: 1
      },
      v = H(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
        rect: y,
        offsetParent: b,
        strategy: c
      }) : y);
    return {
      top: (g.top - v.top + p.top) / $.y,
      bottom: (v.bottom - g.bottom + p.bottom) / $.y,
      left: (g.left - v.left + p.left) / $.x,
      right: (v.right - g.right + p.right) / $.x
    };
  }
  const q = t => ({
      name: "arrow",
      options: t,
      async fn(e) {
        const {
            x: n,
            y: o,
            placement: i,
            rects: s,
            platform: r,
            elements: l
          } = e,
          {
            element: c,
            padding: a = 0
          } = I(t, e) || {};
        if (null == c) return {};
        const u = D(a),
          f = {
            x: n,
            y: o
          },
          h = M(i),
          d = k(h),
          p = await r.getDimensions(c),
          m = "y" === h,
          g = m ? "top" : "left",
          y = m ? "bottom" : "right",
          b = m ? "clientHeight" : "clientWidth",
          x = s.reference[d] + s.reference[h] - f[h] - s.floating[d],
          $ = f[h] - s.reference[h],
          w = await (null == r.getOffsetParent ? void 0 : r.getOffsetParent(c));
        let O = w ? w[b] : 0;
        O && (await (null == r.isElement ? void 0 : r.isElement(w))) || (O = l.floating[b] || s.floating[d]);
        const E = x / 2 - $ / 2,
          T = O / 2 - p[d] / 2 - 1,
          S = v(u[g], T),
          _ = v(u[y], T),
          L = S,
          C = O - p[d] - _,
          R = O / 2 - p[d] / 2 + E,
          j = A(L, R, C),
          F = null != P(i) && R != j && s.reference[d] / 2 - (R < L ? S : _) - p[d] / 2 < 0 ? R < L ? L - R : C - R : 0;
        return {
          [h]: f[h] - F,
          data: {
            [h]: j,
            centerOffset: R - j + F
          }
        };
      }
    }),
    z = function (t) {
      return void 0 === t && (t = {}), {
        name: "flip",
        options: t,
        async fn(e) {
          var n;
          const {
              placement: o,
              middlewareData: i,
              rects: s,
              initialPlacement: r,
              platform: l,
              elements: c
            } = e,
            a = I(t, e),
            {
              mainAxis: u = !0,
              crossAxis: f = !0,
              fallbackPlacements: h,
              fallbackStrategy: d = "bestFit",
              fallbackAxisSideDirection: p = "none",
              flipAlignment: m = !0
            } = a,
            g = $(a, B),
            y = L(o),
            b = L(r) === r,
            x = await (null == l.isRTL ? void 0 : l.isRTL(c.floating)),
            v = h || (b || !m ? [F(r)] : function (t) {
              const e = F(t);
              return [j(t), e, j(e)];
            }(r));
          h || "none" === p || v.push(...function (t, e, n, o) {
            const i = P(t);
            let s = function (t, e, n) {
              const o = ["left", "right"],
                i = ["right", "left"],
                s = ["top", "bottom"],
                r = ["bottom", "top"];
              switch (t) {
                case "top":
                case "bottom":
                  return n ? e ? i : o : e ? o : i;
                case "left":
                case "right":
                  return e ? s : r;
                default:
                  return [];
              }
            }(L(t), "start" === n, o);
            return i && (s = s.map(t => t + "-" + i), e && (s = s.concat(s.map(j)))), s;
          }(r, m, p, x));
          const w = [r, ...v],
            O = await W(e, g),
            E = [];
          let T = (null == (n = i.flip) ? void 0 : n.overflows) || [];
          if (u && E.push(O[y]), f) {
            const t = function (t, e, n) {
              void 0 === n && (n = !1);
              const o = P(t),
                i = M(t),
                s = k(i);
              let r = "x" === i ? o === (n ? "end" : "start") ? "right" : "left" : "start" === o ? "bottom" : "top";
              return e.reference[s] > e.floating[s] && (r = F(r)), [r, F(r)];
            }(o, s, x);
            E.push(O[t[0]], O[t[1]]);
          }
          if (T = [...T, {
            placement: o,
            overflows: E
          }], !E.every(t => t <= 0)) {
            var S, _;
            const t = ((null == (S = i.flip) ? void 0 : S.index) || 0) + 1,
              e = w[t];
            if (e) return {
              data: {
                index: t,
                overflows: T
              },
              reset: {
                placement: e
              }
            };
            let n = null == (_ = T.filter(t => t.overflows[0] <= 0).sort((t, e) => t.overflows[1] - e.overflows[1])[0]) ? void 0 : _.placement;
            if (!n) switch (d) {
              case "bestFit":
                {
                  var A;
                  const t = null == (A = T.map(t => [t.placement, t.overflows.filter(t => t > 0).reduce((t, e) => t + e, 0)]).sort((t, e) => t[1] - e[1])[0]) ? void 0 : A[0];
                  t && (n = t);
                  break;
                }
              case "initialPlacement":
                n = r;
            }
            if (o !== n) return {
              reset: {
                placement: n
              }
            };
          }
          return {};
        }
      };
    },
    U = function (t) {
      return void 0 === t && (t = {}), {
        name: "shift",
        options: t,
        async fn(e) {
          const {
              x: n,
              y: o,
              placement: i
            } = e,
            s = I(t, e),
            {
              mainAxis: r = !0,
              crossAxis: l = !1,
              limiter: c = {
                fn: t => {
                  let {
                    x: e,
                    y: n
                  } = t;
                  return {
                    x: e,
                    y: n
                  };
                }
              }
            } = s,
            a = $(s, N),
            u = {
              x: n,
              y: o
            },
            f = await W(e, a),
            h = R(L(i)),
            d = C(h);
          let p = u[d],
            m = u[h];
          if (r) {
            const t = "y" === d ? "bottom" : "right";
            p = A(p + f["y" === d ? "top" : "left"], p, p - f[t]);
          }
          if (l) {
            const t = "y" === h ? "bottom" : "right";
            m = A(m + f["y" === h ? "top" : "left"], m, m - f[t]);
          }
          const g = c.fn(x({}, e, {
            [d]: p,
            [h]: m
          }));
          return x({}, g, {
            data: {
              x: g.x - n,
              y: g.y - o
            }
          });
        }
      };
    },
    Y = function (t) {
      return void 0 === t && (t = {}), {
        options: t,
        fn(e) {
          const {
              x: n,
              y: o,
              placement: i,
              rects: s,
              middlewareData: r
            } = e,
            {
              offset: l = 0,
              mainAxis: c = !0,
              crossAxis: a = !0
            } = I(t, e),
            u = {
              x: n,
              y: o
            },
            f = R(i),
            h = C(f);
          let d = u[h],
            p = u[f];
          const m = I(l, e),
            g = "number" == typeof m ? {
              mainAxis: m,
              crossAxis: 0
            } : x({
              mainAxis: 0,
              crossAxis: 0
            }, m);
          if (c) {
            const t = "y" === h ? "height" : "width",
              e = s.reference[h] - s.floating[t] + g.mainAxis,
              n = s.reference[h] + s.reference[t] - g.mainAxis;
            d < e ? d = e : d > n && (d = n);
          }
          if (a) {
            var y, b;
            const t = "y" === h ? "width" : "height",
              e = ["top", "left"].includes(L(i)),
              n = s.reference[f] - s.floating[t] + (e && (null == (y = r.offset) ? void 0 : y[f]) || 0) + (e ? 0 : g.crossAxis),
              o = s.reference[f] + s.reference[t] + (e ? 0 : (null == (b = r.offset) ? void 0 : b[f]) || 0) - (e ? g.crossAxis : 0);
            p < n ? p = n : p > o && (p = o);
          }
          return {
            [h]: d,
            [f]: p
          };
        }
      };
    };
  function X(t) {
    return G(t) ? (t.nodeName || "").toLowerCase() : "#document";
  }
  function Z(t) {
    var e;
    return (null == t || null == (e = t.ownerDocument) ? void 0 : e.defaultView) || window;
  }
  function K(t) {
    var e;
    return null == (e = (G(t) ? t.ownerDocument : t.document) || window.document) ? void 0 : e.documentElement;
  }
  function G(t) {
    return t instanceof Node || t instanceof Z(t).Node;
  }
  function J(t) {
    return t instanceof Element || t instanceof Z(t).Element;
  }
  function Q(t) {
    return t instanceof HTMLElement || t instanceof Z(t).HTMLElement;
  }
  function tt(t) {
    return "undefined" != typeof ShadowRoot && (t instanceof ShadowRoot || t instanceof Z(t).ShadowRoot);
  }
  function et(t) {
    const {
      overflow: e,
      overflowX: n,
      overflowY: o,
      display: i
    } = rt(t);
    return /auto|scroll|overlay|hidden|clip/.test(e + o + n) && !["inline", "contents"].includes(i);
  }
  function nt(t) {
    return ["table", "td", "th"].includes(X(t));
  }
  function ot(t) {
    const e = it(),
      n = rt(t);
    return "none" !== n.transform || "none" !== n.perspective || !!n.containerType && "normal" !== n.containerType || !e && !!n.backdropFilter && "none" !== n.backdropFilter || !e && !!n.filter && "none" !== n.filter || ["transform", "perspective", "filter"].some(t => (n.willChange || "").includes(t)) || ["paint", "layout", "strict", "content"].some(t => (n.contain || "").includes(t));
  }
  function it() {
    return !("undefined" == typeof CSS || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none");
  }
  function st(t) {
    return ["html", "body", "#document"].includes(X(t));
  }
  function rt(t) {
    return Z(t).getComputedStyle(t);
  }
  function lt(t) {
    return J(t) ? {
      scrollLeft: t.scrollLeft,
      scrollTop: t.scrollTop
    } : {
      scrollLeft: t.pageXOffset,
      scrollTop: t.pageYOffset
    };
  }
  function ct(t) {
    if ("html" === X(t)) return t;
    const e = t.assignedSlot || t.parentNode || tt(t) && t.host || K(t);
    return tt(e) ? e.host : e;
  }
  function at(t) {
    const e = ct(t);
    return st(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : Q(e) && et(e) ? e : at(e);
  }
  function ut(t, e) {
    var n;
    void 0 === e && (e = []);
    const o = at(t),
      i = o === (null == (n = t.ownerDocument) ? void 0 : n.body),
      s = Z(o);
    return i ? e.concat(s, s.visualViewport || [], et(o) ? o : []) : e.concat(o, ut(o));
  }
  function ft(t) {
    const e = rt(t);
    let n = parseFloat(e.width) || 0,
      o = parseFloat(e.height) || 0;
    const i = Q(t),
      s = i ? t.offsetWidth : n,
      r = i ? t.offsetHeight : o,
      l = O(n) !== s || O(o) !== r;
    return l && (n = s, o = r), {
      width: n,
      height: o,
      $: l
    };
  }
  function ht(t) {
    return J(t) ? t : t.contextElement;
  }
  function dt(t) {
    const e = ht(t);
    if (!Q(e)) return T(1);
    const n = e.getBoundingClientRect(),
      {
        width: o,
        height: i,
        $: s
      } = ft(e);
    let r = (s ? O(n.width) : n.width) / o,
      l = (s ? O(n.height) : n.height) / i;
    return r && Number.isFinite(r) || (r = 1), l && Number.isFinite(l) || (l = 1), {
      x: r,
      y: l
    };
  }
  const pt = T(0);
  function mt(t) {
    const e = Z(t);
    return it() && e.visualViewport ? {
      x: e.visualViewport.offsetLeft,
      y: e.visualViewport.offsetTop
    } : pt;
  }
  function gt(t, e, n, o) {
    void 0 === e && (e = !1), void 0 === n && (n = !1);
    const i = t.getBoundingClientRect(),
      s = ht(t);
    let r = T(1);
    e && (o ? J(o) && (r = dt(o)) : r = dt(t));
    const l = function (t, e, n) {
      return void 0 === e && (e = !1), !(!n || e && n !== Z(t)) && e;
    }(s, n, o) ? mt(s) : T(0);
    let c = (i.left + l.x) / r.x,
      a = (i.top + l.y) / r.y,
      u = i.width / r.x,
      f = i.height / r.y;
    if (s) {
      const t = Z(s),
        e = o && J(o) ? Z(o) : o;
      let n = t.frameElement;
      for (; n && o && e !== t;) {
        const t = dt(n),
          e = n.getBoundingClientRect(),
          o = rt(n),
          i = e.left + (n.clientLeft + parseFloat(o.paddingLeft)) * t.x,
          s = e.top + (n.clientTop + parseFloat(o.paddingTop)) * t.y;
        c *= t.x, a *= t.y, u *= t.x, f *= t.y, c += i, a += s, n = Z(n).frameElement;
      }
    }
    return H({
      width: u,
      height: f,
      x: c,
      y: a
    });
  }
  function yt(t) {
    return gt(K(t)).left + lt(t).scrollLeft;
  }
  function bt(t, e, n) {
    let o;
    if ("viewport" === e) o = function (t, e) {
      const n = Z(t),
        o = K(t),
        i = n.visualViewport;
      let s = o.clientWidth,
        r = o.clientHeight,
        l = 0,
        c = 0;
      if (i) {
        s = i.width, r = i.height;
        const t = it();
        (!t || t && "fixed" === e) && (l = i.offsetLeft, c = i.offsetTop);
      }
      return {
        width: s,
        height: r,
        x: l,
        y: c
      };
    }(t, n);else if ("document" === e) o = function (t) {
      const e = K(t),
        n = lt(t),
        o = t.ownerDocument.body,
        i = w(e.scrollWidth, e.clientWidth, o.scrollWidth, o.clientWidth),
        s = w(e.scrollHeight, e.clientHeight, o.scrollHeight, o.clientHeight);
      let r = -n.scrollLeft + yt(t);
      const l = -n.scrollTop;
      return "rtl" === rt(o).direction && (r += w(e.clientWidth, o.clientWidth) - i), {
        width: i,
        height: s,
        x: r,
        y: l
      };
    }(K(t));else if (J(e)) o = function (t, e) {
      const n = gt(t, !0, "fixed" === e),
        o = n.top + t.clientTop,
        i = n.left + t.clientLeft,
        s = Q(t) ? dt(t) : T(1);
      return {
        width: t.clientWidth * s.x,
        height: t.clientHeight * s.y,
        x: i * s.x,
        y: o * s.y
      };
    }(e, n);else {
      const n = mt(t);
      o = x({}, e, {
        x: e.x - n.x,
        y: e.y - n.y
      });
    }
    return H(o);
  }
  function xt(t, e) {
    const n = ct(t);
    return !(n === e || !J(n) || st(n)) && ("fixed" === rt(n).position || xt(n, e));
  }
  function $t(t, e, n) {
    const o = Q(e),
      i = K(e),
      s = "fixed" === n,
      r = gt(t, !0, s, e);
    let l = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const c = T(0);
    if (o || !o && !s) if (("body" !== X(e) || et(i)) && (l = lt(e)), o) {
      const t = gt(e, !0, s, e);
      c.x = t.x + e.clientLeft, c.y = t.y + e.clientTop;
    } else i && (c.x = yt(i));
    return {
      x: r.left + l.scrollLeft - c.x,
      y: r.top + l.scrollTop - c.y,
      width: r.width,
      height: r.height
    };
  }
  function vt(t, e) {
    return Q(t) && "fixed" !== rt(t).position ? e ? e(t) : t.offsetParent : null;
  }
  function wt(t, e) {
    const n = Z(t);
    if (!Q(t)) return n;
    let o = vt(t, e);
    for (; o && nt(o) && "static" === rt(o).position;) o = vt(o, e);
    return o && ("html" === X(o) || "body" === X(o) && "static" === rt(o).position && !ot(o)) ? n : o || function (t) {
      let e = ct(t);
      for (; Q(e) && !st(e);) {
        if (ot(e)) return e;
        e = ct(e);
      }
      return null;
    }(t) || n;
  }
  const Ot = {
    convertOffsetParentRelativeRectToViewportRelativeRect: function (t) {
      let {
        rect: e,
        offsetParent: n,
        strategy: o
      } = t;
      const i = Q(n),
        s = K(n);
      if (n === s) return e;
      let r = {
          scrollLeft: 0,
          scrollTop: 0
        },
        l = T(1);
      const c = T(0);
      if ((i || !i && "fixed" !== o) && (("body" !== X(n) || et(s)) && (r = lt(n)), Q(n))) {
        const t = gt(n);
        l = dt(n), c.x = t.x + n.clientLeft, c.y = t.y + n.clientTop;
      }
      return {
        width: e.width * l.x,
        height: e.height * l.y,
        x: e.x * l.x - r.scrollLeft * l.x + c.x,
        y: e.y * l.y - r.scrollTop * l.y + c.y
      };
    },
    getDocumentElement: K,
    getClippingRect: function (t) {
      let {
        element: e,
        boundary: n,
        rootBoundary: o,
        strategy: i
      } = t;
      const s = "clippingAncestors" === n ? function (t, e) {
          const n = e.get(t);
          if (n) return n;
          let o = ut(t).filter(t => J(t) && "body" !== X(t)),
            i = null;
          const s = "fixed" === rt(t).position;
          let r = s ? ct(t) : t;
          for (; J(r) && !st(r);) {
            const e = rt(r),
              n = ot(r);
            n || "fixed" !== e.position || (i = null), (s ? !n && !i : !n && "static" === e.position && i && ["absolute", "fixed"].includes(i.position) || et(r) && !n && xt(t, r)) ? o = o.filter(t => t !== r) : i = e, r = ct(r);
          }
          return e.set(t, o), o;
        }(e, this._c) : [].concat(n),
        r = [...s, o],
        l = r[0],
        c = r.reduce((t, n) => {
          const o = bt(e, n, i);
          return t.top = w(o.top, t.top), t.right = v(o.right, t.right), t.bottom = v(o.bottom, t.bottom), t.left = w(o.left, t.left), t;
        }, bt(e, l, i));
      return {
        width: c.right - c.left,
        height: c.bottom - c.top,
        x: c.left,
        y: c.top
      };
    },
    getOffsetParent: wt,
    getElementRects: async function (t) {
      let {
        reference: e,
        floating: n,
        strategy: o
      } = t;
      const i = this.getOffsetParent || wt,
        s = this.getDimensions;
      return {
        reference: $t(e, await i(n), o),
        floating: x({
          x: 0,
          y: 0
        }, await s(n))
      };
    },
    getClientRects: function (t) {
      return Array.from(t.getClientRects());
    },
    getDimensions: function (t) {
      return ft(t);
    },
    getScale: dt,
    isElement: J,
    isRTL: function (t) {
      return "rtl" === rt(t).direction;
    }
  };
  function Et(t, e, n, o) {
    void 0 === o && (o = {});
    const {
        ancestorScroll: i = !0,
        ancestorResize: s = !0,
        elementResize: r = "function" == typeof ResizeObserver,
        layoutShift: l = "function" == typeof IntersectionObserver,
        animationFrame: c = !1
      } = o,
      a = ht(t),
      u = i || s ? [...(a ? ut(a) : []), ...ut(e)] : [];
    u.forEach(t => {
      i && t.addEventListener("scroll", n, {
        passive: !0
      }), s && t.addEventListener("resize", n);
    });
    const f = a && l ? function (t, e) {
      let n,
        o = null;
      const i = K(t);
      function s() {
        clearTimeout(n), o && o.disconnect(), o = null;
      }
      return function r(l, c) {
        void 0 === l && (l = !1), void 0 === c && (c = 1), s();
        const {
          left: a,
          top: u,
          width: f,
          height: h
        } = t.getBoundingClientRect();
        if (l || e(), !f || !h) return;
        const d = {
          rootMargin: -E(u) + "px " + -E(i.clientWidth - (a + f)) + "px " + -E(i.clientHeight - (u + h)) + "px " + -E(a) + "px",
          threshold: w(0, v(1, c)) || 1
        };
        let p = !0;
        function m(t) {
          const e = t[0].intersectionRatio;
          if (e !== c) {
            if (!p) return r();
            e ? r(!1, e) : n = setTimeout(() => {
              r(!1, 1e-7);
            }, 100);
          }
          p = !1;
        }
        try {
          o = new IntersectionObserver(m, x({}, d, {
            root: i.ownerDocument
          }));
        } catch (t) {
          o = new IntersectionObserver(m, d);
        }
        o.observe(t);
      }(!0), s;
    }(a, n) : null;
    let h,
      d = -1,
      p = null;
    r && (p = new ResizeObserver(t => {
      let [o] = t;
      o && o.target === a && p && (p.unobserve(e), cancelAnimationFrame(d), d = requestAnimationFrame(() => {
        p && p.observe(e);
      })), n();
    }), a && !c && p.observe(a), p.observe(e));
    let m = c ? gt(t) : null;
    return c && function e() {
      const o = gt(t);
      !m || o.x === m.x && o.y === m.y && o.width === m.width && o.height === m.height || n();
      m = o, h = requestAnimationFrame(e);
    }(), n(), () => {
      u.forEach(t => {
        i && t.removeEventListener("scroll", n), s && t.removeEventListener("resize", n);
      }), f && f(), p && p.disconnect(), p = null, c && cancelAnimationFrame(h);
    };
  }
  const Tt = (t, e, n) => {
    const o = new Map(),
      i = x({
        platform: Ot
      }, n),
      s = x({}, i.platform, {
        _c: o
      });
    return (async (t, e, n) => {
      const {
          placement: o = "bottom",
          strategy: i = "absolute",
          middleware: s = [],
          platform: r
        } = n,
        l = s.filter(Boolean),
        c = await (null == r.isRTL ? void 0 : r.isRTL(e));
      let a = await r.getElementRects({
          reference: t,
          floating: e,
          strategy: i
        }),
        {
          x: u,
          y: f
        } = V(a, o, c),
        h = o,
        d = {},
        p = 0;
      for (let n = 0; n < l.length; n++) {
        const {
            name: s,
            fn: m
          } = l[n],
          {
            x: g,
            y: y,
            data: b,
            reset: $
          } = await m({
            x: u,
            y: f,
            initialPlacement: o,
            placement: h,
            strategy: i,
            middlewareData: d,
            rects: a,
            platform: r,
            elements: {
              reference: t,
              floating: e
            }
          });
        u = null != g ? g : u, f = null != y ? y : f, d = x({}, d, {
          [s]: x({}, d[s], b)
        }), $ && p <= 50 && (p++, "object" == typeof $ && ($.placement && (h = $.placement), $.rects && (a = !0 === $.rects ? await r.getElementRects({
          reference: t,
          floating: e,
          strategy: i
        }) : $.rects), ({
          x: u,
          y: f
        } = V(a, h, c))), n = -1);
      }
      return {
        x: u,
        y: f,
        placement: h,
        strategy: i,
        middlewareData: d
      };
    })(t, e, x({}, i, {
      platform: s
    }));
  };
  function St(t) {
    t.cleanup && t.cleanup();
    const e = t._getResolvedAttachToOptions();
    let n = e.element;
    const o = function (t, e) {
        const n = {
            strategy: "absolute",
            middleware: []
          },
          o = function (t) {
            if (t.options.arrow && t.el) return t.el.querySelector(".shepherd-arrow");
            return !1;
          }(e),
          i = y(t);
        i || (n.middleware.push(z(), U({
          limiter: Y(),
          crossAxis: !0
        })), o && n.middleware.push(q({
          element: o
        })), n.placement = t.on);
        return c(e.options.floatingUIOptions || {}, n);
      }(e, t),
      i = y(e);
    if (i) {
      n = document.body;
      t.shepherdElementComponent.getElement().classList.add("shepherd-centered");
    }
    return t.cleanup = Et(n, t.el, () => {
      t.el ? function (t, e, n, o) {
        Tt(t, e.el, n).then(function (t, e) {
          return ({
            x: n,
            y: o,
            placement: i,
            middlewareData: s
          }) => t.el ? (e ? Object.assign(t.el.style, {
            position: "fixed",
            left: "50%",
            top: "50%",
            transform: "translate(-50%, -50%)"
          }) : Object.assign(t.el.style, {
            position: "absolute",
            left: `${n}px`,
            top: `${o}px`
          }), t.el.dataset.popperPlacement = i, function (t, e) {
            const n = t.querySelector(".shepherd-arrow");
            if (n && e.arrow) {
              const {
                x: t,
                y: o
              } = e.arrow;
              Object.assign(n.style, {
                left: null != t ? `${t}px` : "",
                top: null != o ? `${o}px` : ""
              });
            }
          }(t.el, s), t) : t;
        }(e, o)).then(t => new Promise(e => {
          setTimeout(() => e(t), 300);
        })).then(t => {
          t && t.el && t.el.focus({
            preventScroll: !0
          });
        });
      }(n, t, o, i) : t.cleanup();
    }), t.target = e.element, o;
  }
  function _t() {}
  function At(t, e) {
    for (const n in e) t[n] = e[n];
    return t;
  }
  function It(t) {
    return t();
  }
  function Lt() {
    return Object.create(null);
  }
  function Pt(t) {
    t.forEach(It);
  }
  function Ct(t) {
    return "function" == typeof t;
  }
  function kt(t, e) {
    return t != t ? e == e : t !== e || t && "object" == typeof t || "function" == typeof t;
  }
  function Rt(t, e) {
    t.appendChild(e);
  }
  function Mt(t, e, n) {
    t.insertBefore(e, n || null);
  }
  function jt(t) {
    t.parentNode && t.parentNode.removeChild(t);
  }
  function Ft(t) {
    return document.createElement(t);
  }
  function Dt(t) {
    return document.createElementNS("http://www.w3.org/2000/svg", t);
  }
  function Ht(t) {
    return document.createTextNode(t);
  }
  function Bt() {
    return Ht(" ");
  }
  function Nt(t, e, n, o) {
    return t.addEventListener(e, n, o), () => t.removeEventListener(e, n, o);
  }
  function Vt(t, e, n) {
    null == n ? t.removeAttribute(e) : t.getAttribute(e) !== n && t.setAttribute(e, n);
  }
  const Wt = ["width", "height"];
  function qt(t, e) {
    const n = Object.getOwnPropertyDescriptors(t.__proto__);
    for (const o in e) null == e[o] ? t.removeAttribute(o) : "style" === o ? t.style.cssText = e[o] : "__value" === o ? t.value = t[o] = e[o] : n[o] && n[o].set && -1 === Wt.indexOf(o) ? t[o] = e[o] : Vt(t, o, e[o]);
  }
  function zt(t, e, n) {
    t.classList[n ? "add" : "remove"](e);
  }
  let Ut;
  function Yt(t) {
    Ut = t;
  }
  function Xt() {
    if (!Ut) throw new Error("Function called outside component initialization");
    return Ut;
  }
  function Zt(t) {
    Xt().$$.after_update.push(t);
  }
  const Kt = [],
    Gt = [];
  let Jt = [];
  const Qt = [],
    te = Promise.resolve();
  let ee = !1;
  function ne(t) {
    Jt.push(t);
  }
  const oe = new Set();
  let ie = 0;
  function se() {
    if (0 !== ie) return;
    const t = Ut;
    do {
      try {
        for (; ie < Kt.length;) {
          const t = Kt[ie];
          ie++, Yt(t), re(t.$$);
        }
      } catch (t) {
        throw Kt.length = 0, ie = 0, t;
      }
      for (Yt(null), Kt.length = 0, ie = 0; Gt.length;) Gt.pop()();
      for (let t = 0; t < Jt.length; t += 1) {
        const e = Jt[t];
        oe.has(e) || (oe.add(e), e());
      }
      Jt.length = 0;
    } while (Kt.length);
    for (; Qt.length;) Qt.pop()();
    ee = !1, oe.clear(), Yt(t);
  }
  function re(t) {
    if (null !== t.fragment) {
      t.update(), Pt(t.before_update);
      const e = t.dirty;
      t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, e), t.after_update.forEach(ne);
    }
  }
  const le = new Set();
  let ce;
  function ae() {
    ce = {
      r: 0,
      c: [],
      p: ce
    };
  }
  function ue() {
    ce.r || Pt(ce.c), ce = ce.p;
  }
  function fe(t, e) {
    t && t.i && (le.delete(t), t.i(e));
  }
  function he(t, e, n, o) {
    if (t && t.o) {
      if (le.has(t)) return;
      le.add(t), ce.c.push(() => {
        le.delete(t), o && (n && t.d(1), o());
      }), t.o(e);
    } else o && o();
  }
  function de(t) {
    t && t.c();
  }
  function pe(t, e, n, o) {
    const {
      fragment: i,
      after_update: s
    } = t.$$;
    i && i.m(e, n), o || ne(() => {
      const e = t.$$.on_mount.map(It).filter(Ct);
      t.$$.on_destroy ? t.$$.on_destroy.push(...e) : Pt(e), t.$$.on_mount = [];
    }), s.forEach(ne);
  }
  function me(t, e) {
    const n = t.$$;
    null !== n.fragment && (!function (t) {
      const e = [],
        n = [];
      Jt.forEach(o => -1 === t.indexOf(o) ? e.push(o) : n.push(o)), n.forEach(t => t()), Jt = e;
    }(n.after_update), Pt(n.on_destroy), n.fragment && n.fragment.d(e), n.on_destroy = n.fragment = null, n.ctx = []);
  }
  function ge(t, e) {
    -1 === t.$$.dirty[0] && (Kt.push(t), ee || (ee = !0, te.then(se)), t.$$.dirty.fill(0)), t.$$.dirty[e / 31 | 0] |= 1 << e % 31;
  }
  function ye(t, e, n, o, i, s, r, l = [-1]) {
    const c = Ut;
    Yt(t);
    const a = t.$$ = {
      fragment: null,
      ctx: [],
      props: s,
      update: _t,
      not_equal: i,
      bound: Lt(),
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(e.context || (c ? c.$$.context : [])),
      callbacks: Lt(),
      dirty: l,
      skip_bound: !1,
      root: e.target || c.$$.root
    };
    r && r(a.root);
    let u = !1;
    if (a.ctx = n ? n(t, e.props || {}, (e, n, ...o) => {
      const s = o.length ? o[0] : n;
      return a.ctx && i(a.ctx[e], a.ctx[e] = s) && (!a.skip_bound && a.bound[e] && a.bound[e](s), u && ge(t, e)), n;
    }) : [], a.update(), u = !0, Pt(a.before_update), a.fragment = !!o && o(a.ctx), e.target) {
      if (e.hydrate) {
        const t = function (t) {
          return Array.from(t.childNodes);
        }(e.target);
        a.fragment && a.fragment.l(t), t.forEach(jt);
      } else a.fragment && a.fragment.c();
      e.intro && fe(t.$$.fragment), pe(t, e.target, e.anchor, e.customElement), se();
    }
    Yt(c);
  }
  class be {
    $destroy() {
      me(this, 1), this.$destroy = _t;
    }
    $on(t, e) {
      if (!Ct(e)) return _t;
      const n = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
      return n.push(e), () => {
        const t = n.indexOf(e);
        -1 !== t && n.splice(t, 1);
      };
    }
    $set(t) {
      var e;
      this.$$set && (e = t, 0 !== Object.keys(e).length) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1);
    }
  }
  function xe(t) {
    let e, n, o, i, s;
    return {
      c() {
        e = Ft("button"), Vt(e, "aria-label", n = t[3] ? t[3] : null), Vt(e, "class", o = `${t[1] || ""} shepherd-button ${t[4] ? "shepherd-button-secondary" : ""}`), e.disabled = t[2], Vt(e, "tabindex", "0");
      },
      m(n, o) {
        Mt(n, e, o), e.innerHTML = t[5], i || (s = Nt(e, "click", function () {
          Ct(t[0]) && t[0].apply(this, arguments);
        }), i = !0);
      },
      p(i, [s]) {
        t = i, 32 & s && (e.innerHTML = t[5]), 8 & s && n !== (n = t[3] ? t[3] : null) && Vt(e, "aria-label", n), 18 & s && o !== (o = `${t[1] || ""} shepherd-button ${t[4] ? "shepherd-button-secondary" : ""}`) && Vt(e, "class", o), 4 & s && (e.disabled = t[2]);
      },
      i: _t,
      o: _t,
      d(t) {
        t && jt(e), i = !1, s();
      }
    };
  }
  function $e(t, e, n) {
    let o,
      i,
      s,
      r,
      l,
      c,
      {
        config: a,
        step: f
      } = e;
    function h(t) {
      return u(t) ? t.call(f) : t;
    }
    return t.$$set = t => {
      "config" in t && n(6, a = t.config), "step" in t && n(7, f = t.step);
    }, t.$$.update = () => {
      192 & t.$$.dirty && (n(0, o = a.action ? a.action.bind(f.tour) : null), n(1, i = a.classes), n(2, s = !!a.disabled && h(a.disabled)), n(3, r = a.label ? h(a.label) : null), n(4, l = a.secondary), n(5, c = a.text ? h(a.text) : null));
    }, [o, i, s, r, l, c, a, f];
  }
  class ve extends be {
    constructor(t) {
      super(), ye(this, t, $e, xe, kt, {
        config: 6,
        step: 7
      });
    }
  }
  function we(t, e, n) {
    const o = t.slice();
    return o[2] = e[n], o;
  }
  function Oe(t) {
    let e,
      n,
      o = t[1],
      i = [];
    for (let e = 0; e < o.length; e += 1) i[e] = Ee(we(t, o, e));
    const s = t => he(i[t], 1, 1, () => {
      i[t] = null;
    });
    return {
      c() {
        for (let t = 0; t < i.length; t += 1) i[t].c();
        e = Ht("");
      },
      m(t, o) {
        for (let e = 0; e < i.length; e += 1) i[e] && i[e].m(t, o);
        Mt(t, e, o), n = !0;
      },
      p(t, n) {
        if (3 & n) {
          let r;
          for (o = t[1], r = 0; r < o.length; r += 1) {
            const s = we(t, o, r);
            i[r] ? (i[r].p(s, n), fe(i[r], 1)) : (i[r] = Ee(s), i[r].c(), fe(i[r], 1), i[r].m(e.parentNode, e));
          }
          for (ae(), r = o.length; r < i.length; r += 1) s(r);
          ue();
        }
      },
      i(t) {
        if (!n) {
          for (let t = 0; t < o.length; t += 1) fe(i[t]);
          n = !0;
        }
      },
      o(t) {
        i = i.filter(Boolean);
        for (let t = 0; t < i.length; t += 1) he(i[t]);
        n = !1;
      },
      d(t) {
        !function (t, e) {
          for (let n = 0; n < t.length; n += 1) t[n] && t[n].d(e);
        }(i, t), t && jt(e);
      }
    };
  }
  function Ee(t) {
    let e, n;
    return e = new ve({
      props: {
        config: t[2],
        step: t[0]
      }
    }), {
      c() {
        de(e.$$.fragment);
      },
      m(t, o) {
        pe(e, t, o), n = !0;
      },
      p(t, n) {
        const o = {};
        2 & n && (o.config = t[2]), 1 & n && (o.step = t[0]), e.$set(o);
      },
      i(t) {
        n || (fe(e.$$.fragment, t), n = !0);
      },
      o(t) {
        he(e.$$.fragment, t), n = !1;
      },
      d(t) {
        me(e, t);
      }
    };
  }
  function Te(t) {
    let e,
      n,
      o = t[1] && Oe(t);
    return {
      c() {
        e = Ft("footer"), o && o.c(), Vt(e, "class", "shepherd-footer");
      },
      m(t, i) {
        Mt(t, e, i), o && o.m(e, null), n = !0;
      },
      p(t, [n]) {
        t[1] ? o ? (o.p(t, n), 2 & n && fe(o, 1)) : (o = Oe(t), o.c(), fe(o, 1), o.m(e, null)) : o && (ae(), he(o, 1, 1, () => {
          o = null;
        }), ue());
      },
      i(t) {
        n || (fe(o), n = !0);
      },
      o(t) {
        he(o), n = !1;
      },
      d(t) {
        t && jt(e), o && o.d();
      }
    };
  }
  function Se(t, e, n) {
    let o,
      {
        step: i
      } = e;
    return t.$$set = t => {
      "step" in t && n(0, i = t.step);
    }, t.$$.update = () => {
      1 & t.$$.dirty && n(1, o = i.options.buttons);
    }, [i, o];
  }
  class _e extends be {
    constructor(t) {
      super(), ye(this, t, Se, Te, kt, {
        step: 0
      });
    }
  }
  function Ae(t) {
    let e, n, o, i, s;
    return {
      c() {
        e = Ft("button"), n = Ft("span"), n.textContent = "Ã—", Vt(n, "aria-hidden", "true"), Vt(e, "aria-label", o = t[0].label ? t[0].label : "Close Tour"), Vt(e, "class", "shepherd-cancel-icon"), Vt(e, "type", "button");
      },
      m(o, r) {
        Mt(o, e, r), Rt(e, n), i || (s = Nt(e, "click", t[1]), i = !0);
      },
      p(t, [n]) {
        1 & n && o !== (o = t[0].label ? t[0].label : "Close Tour") && Vt(e, "aria-label", o);
      },
      i: _t,
      o: _t,
      d(t) {
        t && jt(e), i = !1, s();
      }
    };
  }
  function Ie(t, e, n) {
    let {
      cancelIcon: o,
      step: i
    } = e;
    return t.$$set = t => {
      "cancelIcon" in t && n(0, o = t.cancelIcon), "step" in t && n(2, i = t.step);
    }, [o, t => {
      t.preventDefault(), i.cancel();
    }, i];
  }
  class Le extends be {
    constructor(t) {
      super(), ye(this, t, Ie, Ae, kt, {
        cancelIcon: 0,
        step: 2
      });
    }
  }
  function Pe(t) {
    let e;
    return {
      c() {
        e = Ft("h3"), Vt(e, "id", t[1]), Vt(e, "class", "shepherd-title");
      },
      m(n, o) {
        Mt(n, e, o), t[3](e);
      },
      p(t, [n]) {
        2 & n && Vt(e, "id", t[1]);
      },
      i: _t,
      o: _t,
      d(n) {
        n && jt(e), t[3](null);
      }
    };
  }
  function Ce(t, e, n) {
    let {
      labelId: o,
      element: i,
      title: s
    } = e;
    return Zt(() => {
      u(s) && n(2, s = s()), n(0, i.innerHTML = s, i);
    }), t.$$set = t => {
      "labelId" in t && n(1, o = t.labelId), "element" in t && n(0, i = t.element), "title" in t && n(2, s = t.title);
    }, [i, o, s, function (t) {
      Gt[t ? "unshift" : "push"](() => {
        i = t, n(0, i);
      });
    }];
  }
  class ke extends be {
    constructor(t) {
      super(), ye(this, t, Ce, Pe, kt, {
        labelId: 1,
        element: 0,
        title: 2
      });
    }
  }
  function Re(t) {
    let e, n;
    return e = new ke({
      props: {
        labelId: t[0],
        title: t[2]
      }
    }), {
      c() {
        de(e.$$.fragment);
      },
      m(t, o) {
        pe(e, t, o), n = !0;
      },
      p(t, n) {
        const o = {};
        1 & n && (o.labelId = t[0]), 4 & n && (o.title = t[2]), e.$set(o);
      },
      i(t) {
        n || (fe(e.$$.fragment, t), n = !0);
      },
      o(t) {
        he(e.$$.fragment, t), n = !1;
      },
      d(t) {
        me(e, t);
      }
    };
  }
  function Me(t) {
    let e, n;
    return e = new Le({
      props: {
        cancelIcon: t[3],
        step: t[1]
      }
    }), {
      c() {
        de(e.$$.fragment);
      },
      m(t, o) {
        pe(e, t, o), n = !0;
      },
      p(t, n) {
        const o = {};
        8 & n && (o.cancelIcon = t[3]), 2 & n && (o.step = t[1]), e.$set(o);
      },
      i(t) {
        n || (fe(e.$$.fragment, t), n = !0);
      },
      o(t) {
        he(e.$$.fragment, t), n = !1;
      },
      d(t) {
        me(e, t);
      }
    };
  }
  function je(t) {
    let e,
      n,
      o,
      i = t[2] && Re(t),
      s = t[3] && t[3].enabled && Me(t);
    return {
      c() {
        e = Ft("header"), i && i.c(), n = Bt(), s && s.c(), Vt(e, "class", "shepherd-header");
      },
      m(t, r) {
        Mt(t, e, r), i && i.m(e, null), Rt(e, n), s && s.m(e, null), o = !0;
      },
      p(t, [o]) {
        t[2] ? i ? (i.p(t, o), 4 & o && fe(i, 1)) : (i = Re(t), i.c(), fe(i, 1), i.m(e, n)) : i && (ae(), he(i, 1, 1, () => {
          i = null;
        }), ue()), t[3] && t[3].enabled ? s ? (s.p(t, o), 8 & o && fe(s, 1)) : (s = Me(t), s.c(), fe(s, 1), s.m(e, null)) : s && (ae(), he(s, 1, 1, () => {
          s = null;
        }), ue());
      },
      i(t) {
        o || (fe(i), fe(s), o = !0);
      },
      o(t) {
        he(i), he(s), o = !1;
      },
      d(t) {
        t && jt(e), i && i.d(), s && s.d();
      }
    };
  }
  function Fe(t, e, n) {
    let o,
      i,
      {
        labelId: s,
        step: r
      } = e;
    return t.$$set = t => {
      "labelId" in t && n(0, s = t.labelId), "step" in t && n(1, r = t.step);
    }, t.$$.update = () => {
      2 & t.$$.dirty && (n(2, o = r.options.title), n(3, i = r.options.cancelIcon));
    }, [s, r, o, i];
  }
  class De extends be {
    constructor(t) {
      super(), ye(this, t, Fe, je, kt, {
        labelId: 0,
        step: 1
      });
    }
  }
  function He(t) {
    let e;
    return {
      c() {
        e = Ft("div"), Vt(e, "class", "shepherd-text"), Vt(e, "id", t[1]);
      },
      m(n, o) {
        Mt(n, e, o), t[3](e);
      },
      p(t, [n]) {
        2 & n && Vt(e, "id", t[1]);
      },
      i: _t,
      o: _t,
      d(n) {
        n && jt(e), t[3](null);
      }
    };
  }
  function Be(t, e, n) {
    let {
      descriptionId: o,
      element: i,
      step: s
    } = e;
    return Zt(() => {
      let {
        text: t
      } = s.options;
      u(t) && (t = t.call(s)), a(t) ? i.appendChild(t) : n(0, i.innerHTML = t, i);
    }), t.$$set = t => {
      "descriptionId" in t && n(1, o = t.descriptionId), "element" in t && n(0, i = t.element), "step" in t && n(2, s = t.step);
    }, [i, o, s, function (t) {
      Gt[t ? "unshift" : "push"](() => {
        i = t, n(0, i);
      });
    }];
  }
  class Ne extends be {
    constructor(t) {
      super(), ye(this, t, Be, He, kt, {
        descriptionId: 1,
        element: 0,
        step: 2
      });
    }
  }
  function Ve(t) {
    let e, n;
    return e = new De({
      props: {
        labelId: t[1],
        step: t[2]
      }
    }), {
      c() {
        de(e.$$.fragment);
      },
      m(t, o) {
        pe(e, t, o), n = !0;
      },
      p(t, n) {
        const o = {};
        2 & n && (o.labelId = t[1]), 4 & n && (o.step = t[2]), e.$set(o);
      },
      i(t) {
        n || (fe(e.$$.fragment, t), n = !0);
      },
      o(t) {
        he(e.$$.fragment, t), n = !1;
      },
      d(t) {
        me(e, t);
      }
    };
  }
  function We(t) {
    let e, n;
    return e = new Ne({
      props: {
        descriptionId: t[0],
        step: t[2]
      }
    }), {
      c() {
        de(e.$$.fragment);
      },
      m(t, o) {
        pe(e, t, o), n = !0;
      },
      p(t, n) {
        const o = {};
        1 & n && (o.descriptionId = t[0]), 4 & n && (o.step = t[2]), e.$set(o);
      },
      i(t) {
        n || (fe(e.$$.fragment, t), n = !0);
      },
      o(t) {
        he(e.$$.fragment, t), n = !1;
      },
      d(t) {
        me(e, t);
      }
    };
  }
  function qe(t) {
    let e, n;
    return e = new _e({
      props: {
        step: t[2]
      }
    }), {
      c() {
        de(e.$$.fragment);
      },
      m(t, o) {
        pe(e, t, o), n = !0;
      },
      p(t, n) {
        const o = {};
        4 & n && (o.step = t[2]), e.$set(o);
      },
      i(t) {
        n || (fe(e.$$.fragment, t), n = !0);
      },
      o(t) {
        he(e.$$.fragment, t), n = !1;
      },
      d(t) {
        me(e, t);
      }
    };
  }
  function ze(t) {
    let e,
      n,
      o,
      i,
      s = !h(t[2].options.title) || t[2].options.cancelIcon && t[2].options.cancelIcon.enabled,
      r = !h(t[2].options.text),
      l = Array.isArray(t[2].options.buttons) && t[2].options.buttons.length,
      c = s && Ve(t),
      a = r && We(t),
      u = l && qe(t);
    return {
      c() {
        e = Ft("div"), c && c.c(), n = Bt(), a && a.c(), o = Bt(), u && u.c(), Vt(e, "class", "shepherd-content");
      },
      m(t, s) {
        Mt(t, e, s), c && c.m(e, null), Rt(e, n), a && a.m(e, null), Rt(e, o), u && u.m(e, null), i = !0;
      },
      p(t, [i]) {
        4 & i && (s = !h(t[2].options.title) || t[2].options.cancelIcon && t[2].options.cancelIcon.enabled), s ? c ? (c.p(t, i), 4 & i && fe(c, 1)) : (c = Ve(t), c.c(), fe(c, 1), c.m(e, n)) : c && (ae(), he(c, 1, 1, () => {
          c = null;
        }), ue()), 4 & i && (r = !h(t[2].options.text)), r ? a ? (a.p(t, i), 4 & i && fe(a, 1)) : (a = We(t), a.c(), fe(a, 1), a.m(e, o)) : a && (ae(), he(a, 1, 1, () => {
          a = null;
        }), ue()), 4 & i && (l = Array.isArray(t[2].options.buttons) && t[2].options.buttons.length), l ? u ? (u.p(t, i), 4 & i && fe(u, 1)) : (u = qe(t), u.c(), fe(u, 1), u.m(e, null)) : u && (ae(), he(u, 1, 1, () => {
          u = null;
        }), ue());
      },
      i(t) {
        i || (fe(c), fe(a), fe(u), i = !0);
      },
      o(t) {
        he(c), he(a), he(u), i = !1;
      },
      d(t) {
        t && jt(e), c && c.d(), a && a.d(), u && u.d();
      }
    };
  }
  function Ue(t, e, n) {
    let {
      descriptionId: o,
      labelId: i,
      step: s
    } = e;
    return t.$$set = t => {
      "descriptionId" in t && n(0, o = t.descriptionId), "labelId" in t && n(1, i = t.labelId), "step" in t && n(2, s = t.step);
    }, [o, i, s];
  }
  class Ye extends be {
    constructor(t) {
      super(), ye(this, t, Ue, ze, kt, {
        descriptionId: 0,
        labelId: 1,
        step: 2
      });
    }
  }
  function Xe(t) {
    let e;
    return {
      c() {
        e = Ft("div"), Vt(e, "class", "shepherd-arrow"), Vt(e, "data-popper-arrow", "");
      },
      m(t, n) {
        Mt(t, e, n);
      },
      d(t) {
        t && jt(e);
      }
    };
  }
  function Ze(t) {
    let e,
      n,
      o,
      i,
      s,
      r,
      l,
      c,
      a = t[4].options.arrow && t[4].options.attachTo && t[4].options.attachTo.element && t[4].options.attachTo.on && Xe();
    o = new Ye({
      props: {
        descriptionId: t[2],
        labelId: t[3],
        step: t[4]
      }
    });
    let u = [{
        "aria-describedby": i = h(t[4].options.text) ? null : t[2]
      }, {
        "aria-labelledby": s = t[4].options.title ? t[3] : null
      }, t[1], {
        role: "dialog"
      }, {
        tabindex: "0"
      }],
      f = {};
    for (let t = 0; t < u.length; t += 1) f = At(f, u[t]);
    return {
      c() {
        e = Ft("div"), a && a.c(), n = Bt(), de(o.$$.fragment), qt(e, f), zt(e, "shepherd-has-cancel-icon", t[5]), zt(e, "shepherd-has-title", t[6]), zt(e, "shepherd-element", !0);
      },
      m(i, s) {
        Mt(i, e, s), a && a.m(e, null), Rt(e, n), pe(o, e, null), t[13](e), r = !0, l || (c = Nt(e, "keydown", t[7]), l = !0);
      },
      p(t, [l]) {
        t[4].options.arrow && t[4].options.attachTo && t[4].options.attachTo.element && t[4].options.attachTo.on ? a || (a = Xe(), a.c(), a.m(e, n)) : a && (a.d(1), a = null);
        const c = {};
        4 & l && (c.descriptionId = t[2]), 8 & l && (c.labelId = t[3]), 16 & l && (c.step = t[4]), o.$set(c), qt(e, f = function (t, e) {
          const n = {},
            o = {},
            i = {
              $$scope: 1
            };
          let s = t.length;
          for (; s--;) {
            const r = t[s],
              l = e[s];
            if (l) {
              for (const t in r) t in l || (o[t] = 1);
              for (const t in l) i[t] || (n[t] = l[t], i[t] = 1);
              t[s] = l;
            } else for (const t in r) i[t] = 1;
          }
          for (const t in o) t in n || (n[t] = void 0);
          return n;
        }(u, [(!r || 20 & l && i !== (i = h(t[4].options.text) ? null : t[2])) && {
          "aria-describedby": i
        }, (!r || 24 & l && s !== (s = t[4].options.title ? t[3] : null)) && {
          "aria-labelledby": s
        }, 2 & l && t[1], {
          role: "dialog"
        }, {
          tabindex: "0"
        }])), zt(e, "shepherd-has-cancel-icon", t[5]), zt(e, "shepherd-has-title", t[6]), zt(e, "shepherd-element", !0);
      },
      i(t) {
        r || (fe(o.$$.fragment, t), r = !0);
      },
      o(t) {
        he(o.$$.fragment, t), r = !1;
      },
      d(n) {
        n && jt(e), a && a.d(), me(o), t[13](null), l = !1, c();
      }
    };
  }
  function Ke(t) {
    return t.split(" ").filter(t => !!t.length);
  }
  function Ge(t, e, n) {
    let o,
      i,
      s,
      {
        classPrefix: r,
        element: l,
        descriptionId: c,
        firstFocusableElement: a,
        focusableElements: u,
        labelId: h,
        lastFocusableElement: d,
        step: p,
        dataStepId: m
      } = e;
    var g;
    g = () => {
      n(1, m = {
        [`data-${r}shepherd-step-id`]: p.id
      }), n(9, u = l.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex="0"]')), n(8, a = u[0]), n(10, d = u[u.length - 1]);
    }, Xt().$$.on_mount.push(g), Zt(() => {
      s !== p.options.classes && (function (t) {
        if (f(t)) {
          const e = Ke(t);
          e.length && l.classList.remove(...e);
        }
      }(s), s = p.options.classes, function (t) {
        if (f(t)) {
          const e = Ke(t);
          e.length && l.classList.add(...e);
        }
      }(s));
    });
    return t.$$set = t => {
      "classPrefix" in t && n(11, r = t.classPrefix), "element" in t && n(0, l = t.element), "descriptionId" in t && n(2, c = t.descriptionId), "firstFocusableElement" in t && n(8, a = t.firstFocusableElement), "focusableElements" in t && n(9, u = t.focusableElements), "labelId" in t && n(3, h = t.labelId), "lastFocusableElement" in t && n(10, d = t.lastFocusableElement), "step" in t && n(4, p = t.step), "dataStepId" in t && n(1, m = t.dataStepId);
    }, t.$$.update = () => {
      16 & t.$$.dirty && (n(5, o = p.options && p.options.cancelIcon && p.options.cancelIcon.enabled), n(6, i = p.options && p.options.title));
    }, [l, m, c, h, p, o, i, t => {
      const {
        tour: e
      } = p;
      switch (t.keyCode) {
        case 9:
          if (0 === u.length) {
            t.preventDefault();
            break;
          }
          t.shiftKey ? (document.activeElement === a || document.activeElement.classList.contains("shepherd-element")) && (t.preventDefault(), d.focus()) : document.activeElement === d && (t.preventDefault(), a.focus());
          break;
        case 27:
          e.options.exitOnEsc && (t.stopPropagation(), p.cancel());
          break;
        case 37:
          e.options.keyboardNavigation && (t.stopPropagation(), e.back());
          break;
        case 39:
          e.options.keyboardNavigation && (t.stopPropagation(), e.next());
      }
    }, a, u, d, r, () => l, function (t) {
      Gt[t ? "unshift" : "push"](() => {
        l = t, n(0, l);
      });
    }];
  }
  class Je extends be {
    constructor(t) {
      super(), ye(this, t, Ge, Ze, kt, {
        classPrefix: 11,
        element: 0,
        descriptionId: 2,
        firstFocusableElement: 8,
        focusableElements: 9,
        labelId: 3,
        lastFocusableElement: 10,
        step: 4,
        dataStepId: 1,
        getElement: 12
      });
    }
    get getElement() {
      return this.$$.ctx[12];
    }
  }
  class Qe extends d {
    constructor(t, e = {}) {
      return super(t, e), this.tour = t, this.classPrefix = this.tour.options ? g(this.tour.options.classPrefix) : "", this.styles = t.styles, this._resolvedAttachTo = null, p(this), this._setOptions(e), this;
    }
    cancel() {
      this.tour.cancel(), this.trigger("cancel");
    }
    complete() {
      this.tour.complete(), this.trigger("complete");
    }
    destroy() {
      var t;
      (t = this).cleanup && t.cleanup(), t.cleanup = null, a(this.el) && (this.el.remove(), this.el = null), this._updateStepTargetOnHide(), this.trigger("destroy");
    }
    getTour() {
      return this.tour;
    }
    hide() {
      this.tour.modal.hide(), this.trigger("before-hide"), this.el && (this.el.hidden = !0), this._updateStepTargetOnHide(), this.trigger("hide");
    }
    _resolveAttachToOptions() {
      return this._resolvedAttachTo = function (t) {
        const e = t.options.attachTo || {},
          n = Object.assign({}, e);
        if (u(n.element) && (n.element = n.element.call(t)), f(n.element)) {
          try {
            n.element = document.querySelector(n.element);
          } catch (t) {}
          n.element || void 0;
        }
        return n;
      }(this), this._resolvedAttachTo;
    }
    _getResolvedAttachToOptions() {
      return null === this._resolvedAttachTo ? this._resolveAttachToOptions() : this._resolvedAttachTo;
    }
    isOpen() {
      return Boolean(this.el && !this.el.hidden);
    }
    show() {
      return u(this.options.beforeShowPromise) ? Promise.resolve(this.options.beforeShowPromise()).then(() => this._show()) : Promise.resolve(this._show());
    }
    updateStepOptions(t) {
      Object.assign(this.options, t), this.shepherdElementComponent && this.shepherdElementComponent.$set({
        step: this
      });
    }
    getElement() {
      return this.el;
    }
    getTarget() {
      return this.target;
    }
    _createTooltipContent() {
      const t = `${this.id}-description`,
        e = `${this.id}-label`;
      return this.shepherdElementComponent = new Je({
        target: this.tour.options.stepsContainer || document.body,
        props: {
          classPrefix: this.classPrefix,
          descriptionId: t,
          labelId: e,
          step: this,
          styles: this.styles
        }
      }), this.shepherdElementComponent.getElement();
    }
    _scrollTo(t) {
      const {
        element: e
      } = this._getResolvedAttachToOptions();
      u(this.options.scrollToHandler) ? this.options.scrollToHandler(e) : e instanceof Element && "function" == typeof e.scrollIntoView && e.scrollIntoView(t);
    }
    _getClassOptions(t) {
      const e = this.tour && this.tour.options && this.tour.options.defaultStepOptions,
        n = t.classes ? t.classes : "",
        o = e && e.classes ? e.classes : "",
        i = [...n.split(" "), ...o.split(" ")],
        s = new Set(i);
      return Array.from(s).join(" ").trim();
    }
    _setOptions(t = {}) {
      let e = this.tour && this.tour.options && this.tour.options.defaultStepOptions;
      e = c({}, e || {}), this.options = Object.assign({
        arrow: !0
      }, e, t, function (t, e) {
        return {
          floatingUIOptions: c(t.floatingUIOptions || {}, e.floatingUIOptions || {})
        };
      }(e, t));
      const {
        when: n
      } = this.options;
      this.options.classes = this._getClassOptions(t), this.destroy(), this.id = this.options.id || `step-${b()}`, n && Object.keys(n).forEach(t => {
        this.on(t, n[t], this);
      });
    }
    _setupElements() {
      h(this.el) || this.destroy(), this.el = this._createTooltipContent(), this.options.advanceOn && m(this), St(this);
    }
    _show() {
      this.trigger("before-show"), this._resolveAttachToOptions(), this._setupElements(), this.tour.modal || this.tour._setupModal(), this.tour.modal.setupForStep(this), this._styleTargetElementForStep(this), this.el.hidden = !1, this.options.scrollTo && setTimeout(() => {
        this._scrollTo(this.options.scrollTo);
      }), this.el.hidden = !1;
      const t = this.shepherdElementComponent.getElement(),
        e = this.target || document.body;
      e.classList.add(`${this.classPrefix}shepherd-enabled`), e.classList.add(`${this.classPrefix}shepherd-target`), t.classList.add("shepherd-enabled"), this.trigger("show");
    }
    _styleTargetElementForStep(t) {
      const e = t.target;
      e && (t.options.highlightClass && e.classList.add(t.options.highlightClass), e.classList.remove("shepherd-target-click-disabled"), !1 === t.options.canClickTarget && e.classList.add("shepherd-target-click-disabled"));
    }
    _updateStepTargetOnHide() {
      const t = this.target || document.body;
      this.options.highlightClass && t.classList.remove(this.options.highlightClass), t.classList.remove("shepherd-target-click-disabled", `${this.classPrefix}shepherd-enabled`, `${this.classPrefix}shepherd-target`);
    }
  }
  function tn(t) {
    let e, n, o, i, s;
    return {
      c() {
        e = Dt("svg"), n = Dt("path"), Vt(n, "d", t[2]), Vt(e, "class", o = (t[1] ? "shepherd-modal-is-visible" : "") + " shepherd-modal-overlay-container");
      },
      m(o, r) {
        Mt(o, e, r), Rt(e, n), t[11](e), i || (s = Nt(e, "touchmove", t[3]), i = !0);
      },
      p(t, [i]) {
        4 & i && Vt(n, "d", t[2]), 2 & i && o !== (o = (t[1] ? "shepherd-modal-is-visible" : "") + " shepherd-modal-overlay-container") && Vt(e, "class", o);
      },
      i: _t,
      o: _t,
      d(n) {
        n && jt(e), t[11](null), i = !1, s();
      }
    };
  }
  function en(t) {
    if (!t) return null;
    const e = t instanceof HTMLElement && window.getComputedStyle(t).overflowY;
    return "hidden" !== e && "visible" !== e && t.scrollHeight >= t.clientHeight ? t : en(t.parentElement);
  }
  function nn(t, e, n) {
    let {
      element: o,
      openingProperties: i
    } = e;
    b();
    let s,
      r,
      l = !1;
    c();
    function c() {
      n(4, i = {
        width: 0,
        height: 0,
        x: 0,
        y: 0,
        r: 0
      });
    }
    function a() {
      n(1, l = !1), d();
    }
    function u(t = 0, e = 0, o, s) {
      if (s) {
        const {
            y: r,
            height: l
          } = function (t, e) {
            const n = t.getBoundingClientRect();
            let o = n.y || n.top,
              i = n.bottom || o + n.height;
            if (e) {
              const t = e.getBoundingClientRect(),
                n = t.y || t.top,
                s = t.bottom || n + t.height;
              o = Math.max(o, n), i = Math.min(i, s);
            }
            return {
              y: o,
              height: Math.max(i - o, 0)
            };
          }(s, o),
          {
            x: c,
            width: a,
            left: u
          } = s.getBoundingClientRect();
        n(4, i = {
          width: a + 2 * t,
          height: l + 2 * t,
          x: (c || u) - t,
          y: r - t,
          r: e
        });
      } else c();
    }
    function f() {
      n(1, l = !0);
    }
    const h = t => {
      t.preventDefault();
    };
    function d() {
      s && (cancelAnimationFrame(s), s = void 0), window.removeEventListener("touchmove", h, {
        passive: !1
      });
    }
    return t.$$set = t => {
      "element" in t && n(0, o = t.element), "openingProperties" in t && n(4, i = t.openingProperties);
    }, t.$$.update = () => {
      16 & t.$$.dirty && n(2, r = function ({
        width: t,
        height: e,
        x: n = 0,
        y: o = 0,
        r: i = 0
      }) {
        const {
            innerWidth: s,
            innerHeight: r
          } = window,
          {
            topLeft: l = 0,
            topRight: c = 0,
            bottomRight: a = 0,
            bottomLeft: u = 0
          } = "number" == typeof i ? {
            topLeft: i,
            topRight: i,
            bottomRight: i,
            bottomLeft: i
          } : i;
        return `M${s},${r}H0V0H${s}V${r}ZM${n + l},${o}a${l},${l},0,0,0-${l},${l}V${e + o - u}a${u},${u},0,0,0,${u},${u}H${t + n - a}a${a},${a},0,0,0,${a}-${a}V${o + c}a${c},${c},0,0,0-${c}-${c}Z`;
      }(i));
    }, [o, l, r, t => {
      t.stopPropagation();
    }, i, () => o, c, a, u, function (t) {
      d(), t.tour.options.useModalOverlay ? (!function (t) {
        const {
            modalOverlayOpeningPadding: e,
            modalOverlayOpeningRadius: n
          } = t.options,
          o = en(t.target),
          i = () => {
            s = void 0, u(e, n, o, t.target), s = requestAnimationFrame(i);
          };
        i(), window.addEventListener("touchmove", h, {
          passive: !1
        });
      }(t), f()) : a();
    }, f, function (t) {
      Gt[t ? "unshift" : "push"](() => {
        o = t, n(0, o);
      });
    }];
  }
  class on extends be {
    constructor(t) {
      super(), ye(this, t, nn, tn, kt, {
        element: 0,
        openingProperties: 4,
        getElement: 5,
        closeModalOpening: 6,
        hide: 7,
        positionModal: 8,
        setupForStep: 9,
        show: 10
      });
    }
    get getElement() {
      return this.$$.ctx[5];
    }
    get closeModalOpening() {
      return this.$$.ctx[6];
    }
    get hide() {
      return this.$$.ctx[7];
    }
    get positionModal() {
      return this.$$.ctx[8];
    }
    get setupForStep() {
      return this.$$.ctx[9];
    }
    get show() {
      return this.$$.ctx[10];
    }
  }
  const sn = new d();
  class rn extends d {
    constructor(t = {}) {
      super(t), p(this);
      this.options = Object.assign({}, {
        exitOnEsc: !0,
        keyboardNavigation: !0
      }, t), this.classPrefix = g(this.options.classPrefix), this.steps = [], this.addSteps(this.options.steps);
      return ["active", "cancel", "complete", "inactive", "show", "start"].map(t => {
        (t => {
          this.on(t, e => {
            (e = e || {}).tour = this, sn.trigger(t, e);
          });
        })(t);
      }), this._setTourID(), this;
    }
    addStep(t, e) {
      let n = t;
      return n instanceof Qe ? n.tour = this : n = new Qe(this, n), h(e) ? this.steps.push(n) : this.steps.splice(e, 0, n), n;
    }
    addSteps(t) {
      return Array.isArray(t) && t.forEach(t => {
        this.addStep(t);
      }), this;
    }
    back() {
      const t = this.steps.indexOf(this.currentStep);
      this.show(t - 1, !1);
    }
    async cancel() {
      if (this.options.confirmCancel) {
        const t = "function" == typeof this.options.confirmCancel,
          e = this.options.confirmCancelMessage || "Are you sure you want to stop the tour?";
        (t ? await this.options.confirmCancel() : window.confirm(e)) && this._done("cancel");
      } else this._done("cancel");
    }
    complete() {
      this._done("complete");
    }
    getById(t) {
      return this.steps.find(e => e.id === t);
    }
    getCurrentStep() {
      return this.currentStep;
    }
    hide() {
      const t = this.getCurrentStep();
      if (t) return t.hide();
    }
    isActive() {
      return sn.activeTour === this;
    }
    next() {
      const t = this.steps.indexOf(this.currentStep);
      t === this.steps.length - 1 ? this.complete() : this.show(t + 1, !0);
    }
    removeStep(t) {
      const e = this.getCurrentStep();
      this.steps.some((e, n) => {
        if (e.id === t) return e.isOpen() && e.hide(), e.destroy(), this.steps.splice(n, 1), !0;
      }), e && e.id === t && (this.currentStep = void 0, this.steps.length ? this.show(0) : this.cancel());
    }
    show(t = 0, e = !0) {
      const n = f(t) ? this.getById(t) : this.steps[t];
      if (n) {
        this._updateStateBeforeShow();
        u(n.options.showOn) && !n.options.showOn() ? this._skipStep(n, e) : (this.trigger("show", {
          step: n,
          previous: this.currentStep
        }), this.currentStep = n, n.show());
      }
    }
    start() {
      this.trigger("start"), this.focusedElBeforeOpen = document.activeElement, this.currentStep = null, this._setupModal(), this._setupActiveTour(), this.next();
    }
    _done(t) {
      const e = this.steps.indexOf(this.currentStep);
      if (Array.isArray(this.steps) && this.steps.forEach(t => t.destroy()), function (t) {
        if (t) {
          const {
            steps: e
          } = t;
          e.forEach(t => {
            t.options && !1 === t.options.canClickTarget && t.options.attachTo && t.target instanceof HTMLElement && t.target.classList.remove("shepherd-target-click-disabled");
          });
        }
      }(this), this.trigger(t, {
        index: e
      }), sn.activeTour = null, this.trigger("inactive", {
        tour: this
      }), this.modal && this.modal.hide(), ("cancel" === t || "complete" === t) && this.modal) {
        const t = document.querySelector(".shepherd-modal-overlay-container");
        t && t.remove();
      }
      a(this.focusedElBeforeOpen) && this.focusedElBeforeOpen.focus();
    }
    _setupActiveTour() {
      this.trigger("active", {
        tour: this
      }), sn.activeTour = this;
    }
    _setupModal() {
      this.modal = new on({
        target: this.options.modalContainer || document.body,
        props: {
          classPrefix: this.classPrefix,
          styles: this.styles
        }
      });
    }
    _skipStep(t, e) {
      const n = this.steps.indexOf(t);
      if (n === this.steps.length - 1) this.complete();else {
        const t = e ? n + 1 : n - 1;
        this.show(t, e);
      }
    }
    _updateStateBeforeShow() {
      this.currentStep && this.currentStep.hide(), this.isActive() || this._setupActiveTour();
    }
    _setTourID() {
      const t = this.options.tourName || "tour";
      this.id = `${t}--${b()}`;
    }
  }
  const ln = "undefined" == typeof window;
  class cn {
    constructor() {}
  }
  return ln ? Object.assign(sn, {
    Tour: cn,
    Step: cn
  }) : Object.assign(sn, {
    Tour: rn,
    Step: Qe
  }), sn;
});